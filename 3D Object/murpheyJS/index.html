<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>murpheyJS - Enhanced Animation Library</title>
    <style>
        /* Basic styling for the demo elements */
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #f0f2f5;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            color: #333;
        }

        h1 {
            margin-bottom: 30px;
            color: #2c3e50;
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            width: 100%;
            max-width: 800px;
            /* Limit container width */
        }

        .box {
            width: 100px;
            height: 100px;
            background-color: #3498db;
            border-radius: 12px;
            /* Rounded corners */
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.2em;
            font-weight: bold;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
            cursor: pointer;
            transition: box-shadow 0.3s ease;
            will-change: transform, opacity, background-color, border-radius;
            /* Optimize performance */
        }

        .box:hover {
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
        }

        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 20px;
        }

        button {
            padding: 12px 25px;
            font-size: 1em;
            cursor: pointer;
            background-color: #2ecc71;
            color: white;
            border: none;
            border-radius: 8px;
            /* Rounded corners */
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        button:hover {
            background-color: #27ae60;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .progress-control {
            margin-top: 20px;
            width: 80%;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .progress-control label {
            font-weight: bold;
            color: #555;
        }

        .progress-control input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            /* Override default look */
            height: 8px;
            background: #d3d3d3;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
            border-radius: 4px;
        }

        .progress-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .progress-control input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        #status-message {
            margin-top: 20px;
            font-size: 1.1em;
            color: #555;
            min-height: 25px;
            /* Prevent layout shift */
        }

        /* Styles for scroll-triggered elements */
        .scroll-section {
            height: 50vh;
            /* Make sections tall enough to scroll */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            color: #777;
            background-color: #ecf0f1;
            margin-top: 50px;
            border-radius: 12px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            opacity: 0.5;
            /* Initial state for scroll-triggered elements */
            transform: translateY(50px);
            transition: background-color 0.3s ease;
        }

        .scroll-section:nth-child(even) {
            background-color: #e0e6e8;
        }

        .scroll-trigger-box {
            width: 80px;
            height: 80px;
            background-color: #e67e22;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.8em;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            opacity: 0;
            /* Initial state for scroll-triggered box */
            transform: translateX(-100px);
        }
    </style>
</head>

<body>

    <h1>murpheyJS Demo</h1>

    <div class="container">
        <div class="box" id="box1">Box 1</div>
        <div class="box" id="box2">Box 2</div>
        <div class="box" id="box3">Box 3</div>
        <div class="box" id="box4">Box 4</div>
    </div>

    <div class="controls">
        <button id="playAllBtn">Play All</button>
        <button id="pauseAllBtn">Pause All</button>
        <button id="reverseBox1Btn">Reverse Box 1</button>
        <button id="resetAllBtn">Reset All</button>
        <button id="seekBox2Btn">Seek Box 2 (50%)</button>
        <button id="staggerBtn">Stagger Boxes</button>
    </div>

    <div class="progress-control">
        <label for="anim1Progress">Box 1 Progress:</label>
        <input type="range" id="anim1Progress" min="0" max="100" value="0">
    </div>

    <div id="status-message"></div>

    <div class="scroll-section">
        Scroll down to see the next animation!
    </div>

    <div class="scroll-section">
        <div class="scroll-trigger-box" id="scrollBox">Scroll Box</div>
    </div>

    <div class="scroll-section">
        End of demo.
    </div>


    <script>
        // Self-executing anonymous function to create a private scope for the library
        (function () {

            // Default options for animations
            const defaultOptions = {
                duration: 1000, // milliseconds
                easing: 'easeOutQuad', // Default easing function name
                delay: 0, // milliseconds
                fill: 'forwards', // 'none', 'forwards', 'backwards', 'both' (like CSS animations)
                iterations: 1, // Number of times to repeat
                direction: 'normal', // 'normal', 'reverse', 'alternate'
                stagger: 0 // delay between animating multiple elements
            };

            // --- Easing Functions (a selection for demonstration) ---
            // These functions take a progress value (0-1) and return an eased progress value (0-1)
            const easings = {
                linear: t => t,
                easeInQuad: t => t * t,
                easeOutQuad: t => t * (2 - t),
                easeInOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
                easeInCubic: t => t * t * t,
                easeOutCubic: t => (--t) * t * t + 1,
                easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
                easeInSine: t => -Math.cos(t * (Math.PI / 2)) + 1,
                easeOutSine: t => Math.sin(t * (Math.PI / 2)),
                easeInOutSine: t => -0.5 * (Math.cos(Math.PI * t) - 1),
                easeInExpo: t => (t === 0) ? 0 : Math.pow(2, 10 * (t - 1)),
                easeOutExpo: t => (t === 1) ? 1 : 1 - Math.pow(2, -10 * t),
                easeInOutExpo: t => (t === 0) ? 0 : (t === 1) ? 1 : (t < 0.5) ? 0.5 * Math.pow(2, (20 * t) - 10) : 0.5 * (2 - Math.pow(2, (-20 * t) + 10)),
                // Add more as needed
            };

            // --- Utility Functions ---

            /**
             * Converts a CSS property name to its camelCase JavaScript equivalent.
             * e.g., 'background-color' -> 'backgroundColor'
             */
            function camelCase(prop) {
                return prop.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
            }

            /**
             * Converts camelCase to kebab-case.
             * e.g., 'backgroundColor' -> 'background-color'
             */
            function kebabCase(prop) {
                return prop.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, '$1-$2').toLowerCase();
            }

            /**
             * Applies styles directly to an element.
             */
            function applyStyles(element, styles) {
                for (const prop in styles) {
                    if (styles.hasOwnProperty(prop)) {
                        element.style[camelCase(prop)] = styles[prop];
                    }
                }
            }

            /**
             * Parses a CSS color string (hex or rgb/rgba) into an RGB array.
             * Returns [r, g, b] or [r, g, b, a].
             */
            function parseColor(color) {
                let r, g, b, a = 1;
                if (color.startsWith('#')) {
                    const hex = color.slice(1);
                    if (hex.length === 3) {
                        r = parseInt(hex[0] + hex[0], 16);
                        g = parseInt(hex[1] + hex[1], 16);
                        b = parseInt(hex[2] + hex[2], 16);
                    } else if (hex.length === 6) {
                        r = parseInt(hex.substring(0, 2), 16);
                        g = parseInt(hex.substring(2, 4), 16);
                        b = parseInt(hex.substring(4, 6), 16);
                    }
                } else if (color.startsWith('rgb')) {
                    const parts = color.match(/\d+/g).map(Number);
                    [r, g, b] = parts;
                    if (color.startsWith('rgba')) {
                        a = parseFloat(color.match(/[\d.]+\)/g)[0].slice(0, -1));
                    }
                }
                return [r, g, b, a];
            }

            /**
             * Formats an RGB(A) array back into a CSS color string.
             */
            function formatColor(rgbArray) {
                const [r, g, b, a] = rgbArray;
                if (a !== undefined && a < 1) {
                    return `rgba(${Math.round(r)},${Math.round(g)},${Math.round(b)},${a.toFixed(3)})`;
                }
                return `rgb(${Math.round(r)},${Math.round(g)},${Math.round(b)})`;
            }

            // --- The Main Anim Class ---

            class Anim {
                constructor(element, properties, options = {}) {
                    // Ensure element is a single DOM element for this Anim instance
                    this.element = element;

                    this.properties = properties; // e.g., { x: 100, opacity: 0.5, backgroundColor: 'red' }
                    this.options = { ...defaultOptions, ...options };

                    this.startTime = 0;
                    this.rafId = null; // requestAnimationFrame ID
                    this.isPlaying = false;
                    this.isFinished = false;
                    this.progress = 0; // Current animation progress (0 to 1)

                    this.initialStates = new Map(); // Stores initial CSS states for the element
                    this.targetStates = new Map();   // Stores target CSS states for the element

                    this.callbacks = { // Event callbacks
                        onStart: [],
                        onUpdate: [],
                        onComplete: [],
                        onReverseComplete: []
                    };

                    this._initialize();
                }

                /**
                 * Initializes the animation by capturing initial states of the element.
                 */
                _initialize() {
                    const el = this.element;
                    const initialProps = {};
                    const targetProps = {};
                    const computedStyle = getComputedStyle(el);

                    for (const prop in this.properties) {
                        if (this.properties.hasOwnProperty(prop)) {
                            const targetValue = this.properties[prop];
                            let initialValue;

                            // Special handling for transform properties (x, y, scale, rotate)
                            if (['x', 'y', 'scale', 'scaleX', 'scaleY', 'rotate', 'rotateX', 'rotateY', 'rotateZ'].includes(prop)) {
                                // For transforms, we need to get the current computed transform values.
                                // This is a simplified approach; a robust library would parse the transform matrix.
                                // For now, we assume initial transforms are default (0 or 1).
                                // If you want to animate from current, you'd need a more complex transform parser.
                                if (prop === 'x' || prop === 'y') {
                                    initialValue = 0; // Assume initial translate is 0
                                } else if (prop.startsWith('scale')) {
                                    initialValue = 1; // Assume initial scale is 1
                                } else if (prop.startsWith('rotate')) {
                                    initialValue = 0; // Assume initial rotate is 0
                                }
                                // Store target value as is, will be converted to CSS transform later
                                initialProps[prop] = initialValue;
                                targetProps[prop] = targetValue;
                            } else {
                                // For other CSS properties, get the current computed style
                                initialValue = computedStyle[camelCase(prop)];
                                initialProps[prop] = initialValue;
                                targetProps[prop] = targetValue;
                            }
                        }
                    }
                    this.initialStates.set(el, initialProps);
                    this.targetStates.set(el, targetProps);
                }

                /**
                 * Interpolates a value between start and end based on progress.
                 * Handles numbers, units (px, %), and basic RGB colors.
                 */
                _getInterpolatedValue(start, end, progress, prop) {
                    const easedProgress = easings[this.options.easing](progress);

                    // Handle numbers directly
                    if (typeof start === 'number' && typeof end === 'number') {
                        return start + (end - start) * easedProgress;
                    }

                    // Handle strings with units (e.g., '100px', '50%')
                    if (typeof start === 'string' && typeof end === 'string') {
                        const startVal = parseFloat(start);
                        const endVal = parseFloat(end);
                        const startUnit = start.match(/[^0-9.-]+$/)?.[0] || '';
                        const endUnit = end.match(/[^0-9.-]+$/)?.[0] || '';

                        if (!isNaN(startVal) && !isNaN(endVal) && startUnit === endUnit) {
                            return (startVal + (endVal - startVal) * easedProgress) + startUnit;
                        }

                        // Basic color interpolation (rgb, rgba, hex)
                        if (prop.includes('color') || prop === 'fill' || prop === 'stroke') {
                            const startColor = parseColor(start);
                            const endColor = parseColor(end);

                            if (startColor && endColor && startColor.length === endColor.length) {
                                const interpolatedR = startColor[0] + (endColor[0] - startColor[0]) * easedProgress;
                                const interpolatedG = startColor[1] + (endColor[1] - startColor[1]) * easedProgress;
                                const interpolatedB = startColor[2] + (endColor[2] - startColor[2]) * easedProgress;
                                const interpolatedA = startColor[3] !== undefined && endColor[3] !== undefined ?
                                    startColor[3] + (endColor[3] - startColor[3]) * easedProgress : undefined;
                                return formatColor([interpolatedR, interpolatedG, interpolatedB, interpolatedA]);
                            }
                        }
                    }

                    // Fallback for unsupported types or mismatched units
                    return progress < 1 ? start : end;
                }

                /**
                 * The main animation loop, called by requestAnimationFrame.
                 */
                _animate(timestamp) {
                    const el = this.element;

                    if (!this.startTime) {
                        this.startTime = timestamp;
                        this.callbacks.onStart.forEach(cb => cb(this));
                    }

                    let elapsed = timestamp - this.startTime;
                    let currentProgress = Math.min(1, Math.max(0, (elapsed - this.options.delay) / this.options.duration));

                    // Handle iteration and direction (normal, reverse, alternate)
                    let effectiveProgress = currentProgress;
                    if (this.options.iterations !== 1 && this.options.iterations !== Infinity) {
                        const iterationCount = Math.floor(currentProgress * this.options.iterations);
                        effectiveProgress = (currentProgress * this.options.iterations) % 1; // Progress within current iteration

                        if (this.options.direction === 'alternate' && iterationCount % 2 !== 0) {
                            effectiveProgress = 1 - effectiveProgress;
                        }
                    } else if (this.options.direction === 'reverse') {
                        effectiveProgress = 1 - effectiveProgress;
                    }


                    if (currentProgress >= 1 && this.options.iterations === 1) {
                        this.progress = 1;
                        this.isFinished = true;
                        this.isPlaying = false;
                    } else if (this.options.iterations !== Infinity && elapsed >= (this.options.duration * this.options.iterations + this.options.delay)) {
                        this.progress = 1; // Ensure final state is reached
                        this.isFinished = true;
                        this.isPlaying = false;
                    } else {
                        this.progress = effectiveProgress;
                    }


                    const currentStyles = {};
                    const initial = this.initialStates.get(el);
                    const target = this.targetStates.get(el);

                    let transformProperties = {}; // Store transform components
                    let hasTransform = false;

                    for (const prop in this.properties) {
                        if (this.properties.hasOwnProperty(prop)) {
                            const startVal = initial[prop];
                            const endVal = target[prop];

                            // Handle transform properties separately
                            if (['x', 'y', 'scale', 'scaleX', 'scaleY', 'rotate', 'rotateX', 'rotateY', 'rotateZ'].includes(prop)) {
                                hasTransform = true;
                                const interpolatedVal = this._getInterpolatedValue(startVal, endVal, this.progress, prop);
                                transformProperties[prop] = interpolatedVal;
                            } else {
                                // General CSS properties
                                const interpolatedVal = this._getInterpolatedValue(startVal, endVal, this.progress, prop);
                                currentStyles[prop] = interpolatedVal;
                            }
                        }
                    }

                    // Construct the transform string from individual transform properties
                    if (hasTransform) {
                        let transformString = '';
                        if (transformProperties.x !== undefined) transformString += `translateX(${transformProperties.x}px) `;
                        if (transformProperties.y !== undefined) transformString += `translateY(${transformProperties.y}px) `;
                        if (transformProperties.scale !== undefined) transformString += `scale(${transformProperties.scale}) `;
                        if (transformProperties.scaleX !== undefined) transformString += `scaleX(${transformProperties.scaleX}) `;
                        if (transformProperties.scaleY !== undefined) transformString += `scaleY(${transformProperties.scaleY}) `;
                        if (transformProperties.rotate !== undefined) transformString += `rotate(${transformProperties.rotate}deg) `;
                        if (transformProperties.rotateX !== undefined) transformString += `rotateX(${transformProperties.rotateX}deg) `;
                        if (transformProperties.rotateY !== undefined) transformString += `rotateY(${transformProperties.rotateY}deg) `;
                        if (transformProperties.rotateZ !== undefined) transformString += `rotateZ(${transformProperties.rotateZ}deg) `;

                        currentStyles.transform = transformString.trim();
                    }

                    applyStyles(el, currentStyles);

                    this.callbacks.onUpdate.forEach(cb => cb(this));

                    if (!this.isFinished) {
                        this.rafId = requestAnimationFrame(this._animate.bind(this));
                    } else {
                        // Ensure final state is applied accurately at the end
                        const target = this.targetStates.get(el);
                        const finalStyles = {};
                        let transformString = '';
                        let hasTransform = false;

                        for (const prop in this.properties) {
                            if (this.properties.hasOwnProperty(prop)) {
                                if (['x', 'y', 'scale', 'scaleX', 'scaleY', 'rotate', 'rotateX', 'rotateY', 'rotateZ'].includes(prop)) {
                                    hasTransform = true;
                                    const val = target[prop];
                                    if (prop === 'x') transformString += `translateX(${val}px) `;
                                    else if (prop === 'y') transformString += `translateY(${val}px) `;
                                    else if (prop === 'scale') transformString += `scale(${val}) `;
                                    else if (prop === 'scaleX') transformString += `scaleX(${val}) `;
                                    else if (prop === 'scaleY') transformString += `scaleY(${val}) `;
                                    else if (prop === 'rotate') transformString += `rotate(${val}deg) `;
                                    else if (prop === 'rotateX') transformString += `rotateX(${val}deg) `;
                                    else if (prop === 'rotateY') transformString += `rotateY(${val}deg) `;
                                    else if (prop === 'rotateZ') transformString += `rotateZ(${val}deg) `;
                                } else {
                                    finalStyles[prop] = target[prop];
                                }
                            }
                        }
                        if (hasTransform) {
                            finalStyles.transform = transformString.trim();
                        }
                        applyStyles(el, finalStyles);

                        this.callbacks.onComplete.forEach(cb => cb(this));
                        // Handle fill property (forwards, backwards, both, none)
                        if (this.options.fill === 'none' || (this.options.fill === 'backwards' && this.progress === 0)) {
                            // Revert to initial state if fill is 'none' or 'backwards' and animation ended at start
                            const initial = this.initialStates.get(el);
                            const resetStyles = {};
                            for (const prop in initial) {
                                if (initial.hasOwnProperty(prop)) {
                                    resetStyles[prop] = initial[prop];
                                }
                            }
                            // Also reset transforms if they were animated
                            resetStyles.transform = ''; // Clear any applied transforms
                            applyStyles(el, resetStyles);
                        }
                    }
                }

                /**
                 * Starts or resumes the animation.
                 */
                play() {
                    if (this.isPlaying) return this;
                    this.isPlaying = true;
                    this.isFinished = false;
                    // Adjust start time to account for current progress when resuming
                    this.startTime = performance.now() - (this.progress * this.options.duration * (this.options.direction === 'reverse' ? -1 : 1));
                    this.rafId = requestAnimationFrame(this._animate.bind(this));
                    return this;
                }

                /**
                 * Pauses the animation.
                 */
                pause() {
                    if (!this.isPlaying) return this;
                    this.isPlaying = false;
                    cancelAnimationFrame(this.rafId);
                    return this;
                }

                /**
                 * Reverses the animation's direction.
                 */
                reverse() {
                    this.options.direction = this.options.direction === 'normal' ? 'reverse' : 'normal';
                    // Swap initial and target states for effective reverse
                    const el = this.element;
                    const currentInitial = this.initialStates.get(el);
                    const currentTarget = this.targetStates.get(el);
                    this.initialStates.set(el, currentTarget);
                    this.targetStates.set(el, currentInitial);

                    this.play();
                    return this;
                }

                /**
                 * Seeks the animation to a specific progress point (0 to 1).
                 */
                seek(progress) {
                    const el = this.element;
                    this.progress = Math.min(1, Math.max(0, progress));
                    // Force an immediate update to reflect the new progress
                    const currentStyles = {};
                    const initial = this.initialStates.get(el);
                    const target = this.targetStates.get(el);
                    let transformProperties = {};
                    let hasTransform = false;

                    for (const prop in this.properties) {
                        if (this.properties.hasOwnProperty(prop)) {
                            const startVal = initial[prop];
                            const endVal = target[prop];

                            if (['x', 'y', 'scale', 'scaleX', 'scaleY', 'rotate', 'rotateX', 'rotateY', 'rotateZ'].includes(prop)) {
                                hasTransform = true;
                                const interpolatedVal = this._getInterpolatedValue(startVal, endVal, this.progress, prop);
                                transformProperties[prop] = interpolatedVal;
                            } else {
                                const interpolatedVal = this._getInterpolatedValue(startVal, endVal, this.progress, prop);
                                currentStyles[prop] = interpolatedVal;
                            }
                        }
                    }

                    if (hasTransform) {
                        let transformString = '';
                        if (transformProperties.x !== undefined) transformString += `translateX(${transformProperties.x}px) `;
                        if (transformProperties.y !== undefined) transformString += `translateY(${transformProperties.y}px) `;
                        if (transformProperties.scale !== undefined) transformString += `scale(${transformProperties.scale}) `;
                        if (transformProperties.scaleX !== undefined) transformString += `scaleX(${transformProperties.scaleX}) `;
                        if (transformProperties.scaleY !== undefined) transformString += `scaleY(${transformProperties.scaleY}) `;
                        if (transformProperties.rotate !== undefined) transformString += `rotate(${transformProperties.rotate}deg) `;
                        if (transformProperties.rotateX !== undefined) transformString += `rotateX(${transformProperties.rotateX}deg) `;
                        if (transformProperties.rotateY !== undefined) transformString += `rotateY(${transformProperties.rotateY}deg) `;
                        if (transformProperties.rotateZ !== undefined) transformString += `rotateZ(${transformProperties.rotateZ}deg) `;
                        currentStyles.transform = transformString.trim();
                    }
                    applyStyles(el, currentStyles);

                    // If currently playing, adjust start time for seamless continuation
                    if (this.isPlaying) {
                        this.startTime = performance.now() - (this.progress * this.options.duration);
                    }
                    return this;
                }

                /**
                 * Resets the animation to its initial state.
                 */
                reset() {
                    this.pause();
                    this.progress = 0;
                    this.isFinished = false;
                    const el = this.element;
                    const initial = this.initialStates.get(el);
                    const resetStyles = {};
                    for (const prop in initial) {
                        if (initial.hasOwnProperty(prop)) {
                            resetStyles[prop] = initial[prop];
                        }
                    }
                    resetStyles.transform = ''; // Clear any applied transforms
                    applyStyles(el, resetStyles);

                    // Re-initialize to ensure initial/target states are correct if reverse was called
                    this._initialize();
                    return this;
                }

                /**
                 * Attaches a callback function to an animation event.
                 */
                on(event, callback) {
                    if (this.callbacks[event]) {
                        this.callbacks[event].push(callback);
                    } else {
                        console.warn(`murpheyJS: Event '${event}' not supported.`);
                    }
                    return this; // For chaining
                }

                // --- Chainable Option Setters (Syntactic Sugar) ---
                duration(ms) { this.options.duration = ms; return this; }
                easing(name) {
                    if (easings[name]) {
                        this.options.easing = name;
                    } else {
                        console.warn(`murpheyJS: Easing function '${name}' not found. Using default.`);
                    }
                    return this;
                }
                delay(ms) { this.options.delay = ms; return this; }
                repeat(iterations) { this.options.iterations = iterations; return this; }
                yoyo(enable) {
                    this.options.direction = enable ? 'alternate' : 'normal';
                    return this;
                }
                fill(mode) { this.options.fill = mode; return this; }
            }

            // --- Global murpheyJS Object ---
            // This is the main entry point for users to create animations.
            window.murpheyJS = {
                /**
                 * Creates a new animation instance or instances (for stagger).
                 * @param {HTMLElement|NodeList|Array<HTMLElement>} elements - The element(s) to animate.
                 * @param {Object} properties - The target CSS properties and their values.
                 * @param {Object} [options] - Optional animation settings including 'stagger'.
                 * @returns {Anim|Array<Anim>} The animation instance(s) for chaining.
                 */
                to: (elements, properties, options) => {
                    const targets = Array.isArray(elements) ? elements :
                        (NodeList.prototype.isPrototypeOf(elements) || HTMLCollection.prototype.isPrototypeOf(elements) ? Array.from(elements) : [elements]);

                    const finalOptions = { ...defaultOptions, ...options };

                    if (finalOptions.stagger > 0 && targets.length > 1) {
                        const anims = [];
                        targets.forEach((el, index) => {
                            const individualOptions = { ...finalOptions, delay: finalOptions.delay + (index * finalOptions.stagger) };
                            anims.push(new Anim(el, properties, individualOptions));
                        });
                        return anims; // Return an array of Anim instances for stagger
                    } else {
                        return new Anim(targets[0], properties, finalOptions); // Return single Anim instance
                    }
                },

                /**
                 * Immediately sets CSS properties on element(s) without animation.
                 * @param {HTMLElement|NodeList|Array<HTMLElement>} elements - The element(s) to set properties on.
                 * @param {Object} properties - The CSS properties and their values to set.
                 * @returns {Object} The murpheyJS global object for potential chaining (e.g., murpheyJS.set().to()).
                 */
                set: (elements, properties) => {
                    const targets = Array.isArray(elements) ? elements :
                        (NodeList.prototype.isPrototypeOf(elements) || HTMLCollection.prototype.isPrototypeOf(elements) ? Array.from(elements) : [elements]);
                    targets.forEach(el => applyStyles(el, properties));
                    return murpheyJS; // Allow chaining from main murpheyJS object for `set`
                },

                easings: easings, // Expose easing functions for users to see or use

                /**
                 * murpheyJS.ScrollTrigger - A basic utility to trigger animations on scroll.
                 * This is a simplified version and does NOT include 'pin' or 'scrub' functionality.
                 * For full 'pin' and 'scrub', a more complex system is needed to manage DOM layout
                 * and precisely link animation progress to scroll position.
                 * @param {Object} config - Configuration object.
                 * @param {HTMLElement} config.trigger - The element that triggers the animation.
                 * @param {Anim} config.animation - The murpheyJS Anim instance to control.
                 * @param {string} [config.start='top center'] - When the trigger element starts entering the viewport.
                 * @param {string} [config.end='bottom center'] - When the trigger element finishes leaving the viewport.
                 * @param {boolean} [config.toggleActions=true] - If true, animation plays on enter, reverses on leave.
                 */
                ScrollTrigger: function (config) {
                    const { trigger, animation, toggleActions = true } = config;

                    if (!trigger || !animation) {
                        console.error("murpheyJS.ScrollTrigger: 'trigger' and 'animation' are required.");
                        return;
                    }

                    // Intersection Observer options.
                    // rootMargin can be used to define the trigger point more precisely.
                    // For simplicity, we'll use default (element enters/leaves viewport).
                    const observerOptions = {
                        root: null, // The viewport
                        rootMargin: '0px',
                        threshold: 0.1 // Trigger when 10% of the element is visible
                    };

                    const observer = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                if (!animation.isPlaying && !animation.isFinished) {
                                    animation.play();
                                    console.log(`ScrollTrigger: ${trigger.id || 'element'} entered viewport, playing animation.`);
                                }
                            } else {
                                if (toggleActions) {
                                    if (animation.isPlaying || !animation.isFinished) {
                                        animation.reverse(); // Or animation.reset() depending on desired behavior
                                        console.log(`ScrollTrigger: ${trigger.id || 'element'} left viewport, reversing animation.`);
                                    }
                                }
                            }
                        });
                    }, observerOptions);

                    observer.observe(trigger);

                    // Return the observer so it can be unobserved if needed
                    return observer;
                }
            };

        })(); // End of self-executing function


        // --- Demo Usage ---
        document.addEventListener('DOMContentLoaded', () => {
            const box1 = document.getElementById('box1');
            const box2 = document.getElementById('box2');
            const box3 = document.getElementById('box3');
            const box4 = document.getElementById('box4');
            const allBoxes = document.querySelectorAll('.box'); // For stagger demo
            const scrollBox = document.getElementById('scrollBox');

            const statusMessage = document.getElementById('status-message');
            const anim1ProgressSlider = document.getElementById('anim1Progress');


            // Animation 1: Basic movement, rotation, opacity, and color change
            const anim1 = murpheyJS.to(box1, {
                x: 200, // translateX by 200px
                y: 50,  // translateY by 50px
                rotate: 360, // rotate by 360 degrees
                opacity: 0.6,
                backgroundColor: '#e74c3c', // Red
                borderRadius: '50%' // Make it a circle
            }, {
                duration: 2000,
                easing: 'easeInOutCubic',
                delay: 200,
                fill: 'forwards'
            })
                .on('onStart', () => statusMessage.textContent = 'Box 1 animation started!')
                .on('onUpdate', (anim) => {
                    // Update slider as animation progresses
                    anim1ProgressSlider.value = (anim.progress * 100).toFixed(0);
                })
                .on('onComplete', () => statusMessage.textContent = 'Box 1 animation complete!');


            // Animation 2: Scale and color change with repeat and yoyo
            const anim2 = murpheyJS.to(box2, {
                scale: 1.5,
                backgroundColor: '#f1c40f', // Yellow
                boxShadow: '0 0 20px rgba(241, 196, 15, 0.8)' // Add shadow
            }, {
                duration: 1200,
                easing: 'easeOutExpo',
                repeat: Infinity, // Repeat indefinitely
                yoyo: true // Go forwards then backwards
            });

            // Animation 3: Simple movement for demo purposes (will be part of stagger later)
            const anim3 = murpheyJS.to(box3, {
                x: -150,
                backgroundColor: '#27ae60' // Green
            }, {
                duration: 1000,
                fill: 'forwards'
            });

            // Animation 4: Width and height animation with a custom easing
            const anim4 = murpheyJS.to(box4, {
                width: '150px',
                height: '70px',
                backgroundColor: 'rgba(155, 89, 182, 0.8)', // Purple with alpha
                rotate: -45
            }, {
                duration: 1800,
                easing: 'easeInSine',
                fill: 'forwards'
            });

            // Scroll-triggered animation
            const scrollAnim = murpheyJS.to(scrollBox, {
                x: 0,
                opacity: 1,
                rotate: 360,
                backgroundColor: '#3498db'
            }, {
                duration: 1000,
                easing: 'easeOutQuad',
                fill: 'forwards'
            });

            // Set initial state for scrollBox (off-screen and transparent)
            murpheyJS.set(scrollBox, { opacity: 0, x: -100 });

            // Create the ScrollTrigger for scrollBox
            murpheyJS.ScrollTrigger({
                trigger: scrollBox,
                animation: scrollAnim,
                toggleActions: true // Play on enter, reverse on leave
            });


            // --- Controls ---
            // Note: For stagger, `murpheyJS.to` returns an array of Anim instances.
            // We need to store them to control them later.
            let staggeredAnims = [];

            const allAnims = [anim1, anim2, anim3, anim4, scrollAnim]; // Include scrollAnim for global controls

            document.getElementById('playAllBtn').addEventListener('click', () => {
                allAnims.forEach(anim => anim.play());
                staggeredAnims.forEach(anim => anim.play()); // Also play any staggered anims
                statusMessage.textContent = 'All animations playing.';
            });

            document.getElementById('pauseAllBtn').addEventListener('click', () => {
                allAnims.forEach(anim => anim.pause());
                staggeredAnims.forEach(anim => anim.pause());
                statusMessage.textContent = 'All animations paused.';
            });

            document.getElementById('reverseBox1Btn').addEventListener('click', () => {
                anim1.reverse();
                statusMessage.textContent = 'Box 1 animation reversed!';
            });

            document.getElementById('resetAllBtn').addEventListener('click', () => {
                allAnims.forEach(anim => anim.reset());
                staggeredAnims.forEach(anim => anim.reset());
                murpheyJS.set(box1, { borderRadius: '12px' }); // Reset borderRadius for box1 manually
                murpheyJS.set(allBoxes, { x: 0, y: 0, opacity: 1, scale: 1, backgroundColor: '#3498db', boxShadow: '0 6px 12px rgba(0,0,0,0.15)', borderRadius: '12px', width: '100px', height: '100px', rotate: 0 }); // Reset all boxes
                murpheyJS.set(scrollBox, { opacity: 0, x: -100 }); // Reset scroll box
                anim1ProgressSlider.value = 0; // Reset slider
                statusMessage.textContent = 'All animations reset.';
            });

            document.getElementById('seekBox2Btn').addEventListener('click', () => {
                anim2.seek(0.5); // Seek to 50% progress
                statusMessage.textContent = 'Box 2 animation sought to 50%.';
            });

            document.getElementById('staggerBtn').addEventListener('click', () => {
                // Reset boxes before staggering
                murpheyJS.set(allBoxes, { x: 0, y: 0, opacity: 1, scale: 1, backgroundColor: '#3498db', boxShadow: '0 6px 12px rgba(0,0,0,0.15)', borderRadius: '12px', width: '100px', height: '100px', rotate: 0 });

                // Create staggered animations
                staggeredAnims = murpheyJS.to(allBoxes, {
                    x: (index) => (index % 2 === 0 ? 100 : -100), // Move even boxes right, odd boxes left
                    rotate: 180,
                    backgroundColor: '#8e44ad' // Purple
                }, {
                    duration: 800,
                    stagger: 150, // 150ms delay between each box
                    easing: 'easeOutQuad',
                    fill: 'forwards'
                });
                // Play all staggered animations
                staggeredAnims.forEach(anim => anim.play());
                statusMessage.textContent = 'Stagger animation started!';
            });


            // UI Progress Control for Box 1
            anim1ProgressSlider.addEventListener('input', (event) => {
                const progress = parseFloat(event.target.value) / 100;
                anim1.seek(progress);
                statusMessage.textContent = `Box 1 progress: ${(progress * 100).toFixed(0)}% (manual)`;
            });

            // Initial setup: set some properties without animation
            murpheyJS.set(allBoxes, { x: 0, y: 0, rotate: 0, opacity: 1, backgroundColor: '#3498db', borderRadius: '12px', width: '100px', height: '100px' });
            murpheyJS.set(box2, { scale: 1, boxShadow: '0 6px 12px rgba(0,0,0,0.15)' });
        });
    </script>
</body>

</html>